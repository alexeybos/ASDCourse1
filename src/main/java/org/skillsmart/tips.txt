1. Только циклы в условия лучше не вкладывать, цикломатическая сложность растёт.
2. Старайтесь вообще не использовать форму цикла while, если только задача явно это не подразумевает (например, расчёт некоторой функции до нужной точности).

Как минимум, всегда меняйте while на for, если внутри while вы используете счётчик, например (неверно):

i = 0
while i < 10
    ...
    i += 1

Правильно так:

for i = 0; i < 10; i += 1
    ...

Само условие со счётчиком может быть и не связано, конечно.

И в общем случае, вместо счётчика может быть некоторое вычисляемое значение:

x = начальное значение
while проверка x
    ...
    x = следующее значение

Правильно так:

for x = начальное значение; проверка x; x = следующее значение
    ...
------------------------------------------------------------------------------------------------------------------------
3. Уточнения для банковского метода в классе BankDynArray:
    "С банком, примерно такая схема: при добавлении элемента например амортизационные 3 (1 реальные расходы + 2 кладем в банк).
    Когда надо выполнять реаллокацию, вопрос неоднозначный, можно по некоторому порогу в банке,
    но лучше когда внутренний массив весь заполнен.
    При удалении амортизационные 2 (1 + 1).
    При реаллокации (добавляем N элементов) - из банка списывается N.
    При уменьшении, в принципе, делать ничего не надо, ну или например немного, 10% * N списать."
4. Уточнения для многомерного динамического массива в классе MultidimensionalDynArray
    "Как-то усложнено, идея, что у нас есть интерфейс добавления элемента в некоторую позицию (i,j,k,...),
    а внутри это может быть обычный одномерный динамический массив. Надо просто корректно реализовать операцию добавления
    элемента (отображение многомерной координаты в линию)."
5. lesson4, task 8 - так делать конечно нельзя, возможна потенциальная ошибка — вы полагаетесь на конкретный порядок вычисления выражения, что в общем случае рискованно.
            Возможно, в выражении сперва будет вычислен не левый pop(), а правый pop() (или наоборот, или в случайном порядке каждый раз из-за оптимизации какой-нибудь).
            Например, у вас в стеке (3, 5) , и может получиться 5-3 или 3-5 в зависимости от порядка, и соответственно разные результаты.
6. lesson7 task 8 (deleteDuplicates) - лучше код не копипастить, а расширить существующий delete флажком например.
           task 11 (getMostCommonValue) - можно словарь в принципе использовать, чтобы "вручную" не искать макс.
7. lesson8 task3: Да, ну смешивать в одном классе логику двух разных структур данных (хэш-таблицы и дин.массива) не очень здорово (мягко говоря),
                  лучше использовать композицию (дин.массив в таблице, или даже сама таблица в дин.массиве).
8. lesson 10 t 4: вместо списка лучше словарь использовать, чтобы не путаться, какой элемент для чего.
             t 6: - частоту по идее с помощью мапы можно отслеживать за O(1). Добавил вам +1000 рейтинга.

9. Совет по использованию рекурсии:
    Всегда старайтесь, чтобы рекурсивный вызов был последним единственным в функции и без дополнительных вычислений,
    тогда компилятор хорошо её оптимизирует (не во всех языках, к сожалению), можно вообще без стека вызовов обойтись
    (т.н. элиминация хвостовой рекурсии — на собеседованиях нередко спрашивают).
    (И если конечно вы не пишите на функциональном языке.)